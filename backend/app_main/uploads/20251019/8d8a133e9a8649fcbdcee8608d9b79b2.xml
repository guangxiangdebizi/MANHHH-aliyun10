<NAME>
æ™ºèƒ½è‡ªé€‚åº”é«˜èƒœç‡ç­–ç•¥|Intelligent Adaptive High Win Rate Strategy
</NAME>
<DESCRIPTION>
é›†æˆå¤šé‡ç¡®è®¤æœºåˆ¶ã€æ™ºèƒ½è¿‡æ»¤å’Œé»‘å¤©é¹…ä¿æŠ¤çš„é¡¶çº§é‡åŒ–ç­–ç•¥
</DESCRIPTION>
<PARAM>
["StrategyMode","ç­–ç•¥æ¨¡å¼","",1,{"required":true,"default":1,"type":"number","options":{"0":"ä¿å®ˆæ¨¡å¼","1":"å¹³è¡¡æ¨¡å¼","2":"æ¿€è¿›æ¨¡å¼"}}]
["BBPeriod","å¸ƒæ—å¸¦å‘¨æœŸ","",20,{"required":true,"default":20,"type":"number"}]
["BBStd","å¸ƒæ—å¸¦æ ‡å‡†å·®","",2,{"required":true,"default":2,"type":"number"}]
["BBWidthFilter","å¸ƒæ—å¸¦å®½åº¦è¿‡æ»¤","",0.005,{"required":true,"default":0.005,"type":"number"}]
["TradeAmount","äº¤æ˜“æ•°é‡","",0.1,{"required":true,"default":0.1,"type":"number"}]
["RSIPeriod","RSIå‘¨æœŸ","",14,{"required":true,"default":14,"type":"number"}]
["MACDFast","MACDå¿«çº¿","",12,{"required":true,"default":12,"type":"number"}]
["MACDSlow","MACDæ…¢çº¿","",26,{"required":true,"default":26,"type":"number"}]
["MACDSignal","MACDä¿¡å·çº¿","",9,{"required":true,"default":9,"type":"number"}]
["ATRPeriod","ATRå‘¨æœŸ","",14,{"required":true,"default":14,"type":"number"}]
["ATRMultiplier","ATRä¹˜æ•°","",2,{"required":true,"default":2,"type":"number"}]
["VolumeFilter","æˆäº¤é‡è¿‡æ»¤å€æ•°","",1.2,{"required":true,"default":1.2,"type":"number"}]
["BlackSwanThreshold","é»‘å¤©é¹…é˜ˆå€¼","",0.15,{"required":true,"default":0.15,"type":"number"}]
["BlackSwanCooling","é»‘å¤©é¹…å†·å´","",7200,{"required":true,"default":7200,"type":"number"}]
["TrendFollowMode","è¶‹åŠ¿è·Ÿéšæ¨¡å¼","",1,{"required":true,"default":1,"type":"number"}]
["DivergenceDetection","èƒŒç¦»æ£€æµ‹","",1,{"required":true,"default":1,"type":"number"}]
["LoopInterval","è½®è¯¢å‘¨æœŸ(ms)","",1000,{"required":true,"default":1000,"type":"number"}]
["$$$__cmd__$$$StrategyMode","åˆ‡æ¢ç­–ç•¥æ¨¡å¼","",2,{"required":true,"default":2,"type":"number"}]
["$$$__cmd__$$$BlackSwan","è°ƒæ•´é»‘å¤©é¹…é˜ˆå€¼","",0.1,{"required":true,"default":0.1,"type":"number"}]
</PARAM>
<CODE>
'''backtest
start: 2024-07-30 00:00:00
end: 2024-08-29 00:00:00
period: 1h
basePeriod: 1h
exchanges: [{"eid":"Binance","currency":"BTC_USDT"}]
'''

import time
import json
import numpy as np

def cancelAll():
    ret = False
    for e in exchanges:
        while True:
            n = 0
            for order in _C(e.GetOrders):
                ret = True
                e.CancelOrder(order.Id)
                n+=1
            if n == 0:
                break
    return ret

def calculate_bollinger_bands(prices, period, std_dev):
    """è®¡ç®—å¸ƒæ—å¸¦"""
    if len(prices) < period:
        return 0, 0, 0, 0
    middle_band = np.mean(prices[-period:])
    std = np.std(prices[-period:])
    upper_band = middle_band + std_dev * std
    lower_band = middle_band - std_dev * std
    bandwidth = (upper_band - lower_band) / middle_band
    return upper_band, middle_band, lower_band, bandwidth

def calculate_rsi(prices, period):
    """è®¡ç®—RSIæŒ‡æ ‡"""
    if len(prices) < period + 1:
        return 50
    deltas = np.diff(prices[-period-1:])
    gains = np.where(deltas > 0, deltas, 0)
    losses = np.where(deltas < 0, -deltas, 0)
    
    avg_gain = np.mean(gains)
    avg_loss = np.mean(losses)
    
    if avg_loss == 0:
        return 100
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def calculate_macd(prices, fast_period, slow_period, signal_period):
    """è®¡ç®—MACDæŒ‡æ ‡"""
    if len(prices) < slow_period:
        return 0, 0, 0
    
    fast_ema = np.mean(prices[-fast_period:])
    slow_ema = np.mean(prices[-slow_period:])
    macd_line = fast_ema - slow_ema
    
    # ç®€åŒ–ä¿¡å·çº¿è®¡ç®—
    signal_line = np.mean(prices[-signal_period:])
    histogram = macd_line - signal_line
    
    return macd_line, signal_line, histogram

def calculate_atr(high_prices, low_prices, close_prices, period):
    """è®¡ç®—ATRæŒ‡æ ‡"""
    if len(high_prices) < period + 1:
        return 0
    
    tr_values = []
    for i in range(1, len(high_prices)):
        high = high_prices[i]
        low = low_prices[i]
        prev_close = close_prices[i-1]
        
        tr1 = high - low
        tr2 = abs(high - prev_close)
        tr3 = abs(low - prev_close)
        tr = max(tr1, tr2, tr3)
        tr_values.append(tr)
    
    return np.mean(tr_values[-period:])

def calculate_volume_signal(current_volume, volume_history, multiplier):
    """è®¡ç®—æˆäº¤é‡ä¿¡å·"""
    if len(volume_history) < 10:
        return True
    
    avg_volume = np.mean(volume_history[-10:])
    return current_volume > avg_volume * multiplier

def detect_rsi_divergence(prices, rsi_values, lookback=10):
    """æ£€æµ‹RSIèƒŒç¦»"""
    if len(prices) < lookback * 2 or len(rsi_values) < lookback * 2:
        return {"bullish": False, "bearish": False}
    
    # å¯»æ‰¾ä»·æ ¼å’ŒRSIçš„æå€¼ç‚¹
    price_highs = []
    price_lows = []
    rsi_highs = []
    rsi_lows = []
    
    # ç®€åŒ–ç‰ˆèƒŒç¦»æ£€æµ‹
    recent_prices = prices[-lookback:]
    recent_rsi = rsi_values[-lookback:]
    
    current_price = prices[-1]
    prev_price = prices[-2]
    current_rsi = rsi_values[-1]
    prev_rsi = rsi_values[-2]
    
    # çœ‹æ¶¨èƒŒç¦»ï¼šä»·æ ¼æ–°ä½ï¼ŒRSIæŠ¬é«˜
    bullish_divergence = (current_price < min(recent_prices[:-1]) and 
                         current_rsi > min(recent_rsi[:-1]) and
                         current_rsi < 40)
    
    # çœ‹è·ŒèƒŒç¦»ï¼šä»·æ ¼æ–°é«˜ï¼ŒRSIé™ä½
    bearish_divergence = (current_price > max(recent_prices[:-1]) and 
                         current_rsi < max(recent_rsi[:-1]) and
                         current_rsi > 60)
    
    return {"bullish": bullish_divergence, "bearish": bearish_divergence}

def detect_market_trend(prices, period=50):
    """æ£€æµ‹å¸‚åœºè¶‹åŠ¿çŠ¶æ€"""
    if len(prices) < period:
        return "unknown"
    
    short_ma = np.mean(prices[-10:])
    long_ma = np.mean(prices[-period:])
    ma_diff = (short_ma - long_ma) / long_ma
    
    if ma_diff > 0.02:
        return "uptrend"
    elif ma_diff < -0.02:
        return "downtrend"
    else:
        return "ranging"

class AdvancedRiskManager:
    def __init__(self):
        self.black_swan_detected = False
        self.black_swan_start_time = 0
        self.max_drawdown = 0
        self.peak_equity = 0
        self.volatility_regime = "normal"
        
    def check_black_swan(self, current_price, price_history, threshold):
        """æ£€æµ‹é»‘å¤©é¹…äº‹ä»¶"""
        if len(price_history) < 10:
            return False
        
        # æ£€æŸ¥ä»·æ ¼å‰§çƒˆæ³¢åŠ¨
        price_changes = np.diff(price_history[-10:]) / price_history[-11:-1]
        max_change = np.max(np.abs(price_changes))
        
        if max_change > threshold:
            self.black_swan_detected = True
            self.black_swan_start_time = time.time()
            self.volatility_regime = "extreme"
            Log(f"ğŸš¨ é»‘å¤©é¹…äº‹ä»¶æ£€æµ‹! æœ€å¤§æ³¢åŠ¨: {_N(max_change*100,2)}%")
            return True
        
        # æ£€æŸ¥æ˜¯å¦ç»“æŸé»‘å¤©é¹…çŠ¶æ€
        if self.black_swan_detected and time.time() - self.black_swan_start_time > 7200:  # 2å°æ—¶
            self.black_swan_detected = False
            self.volatility_regime = "normal"
            Log("é»‘å¤©é¹…çŠ¶æ€ç»“æŸ")
        
        return self.black_swan_detected
    
    def calculate_drawdown(self, current_equity):
        """è®¡ç®—å›æ’¤"""
        if current_equity > self.peak_equity:
            self.peak_equity = current_equity
        
        if self.peak_equity == 0:
            return 0
        
        drawdown = (self.peak_equity - current_equity) / self.peak_equity
        self.max_drawdown = max(self.max_drawdown, drawdown)
        return drawdown

class SmartSignalGenerator:
    def __init__(self):
        self.price_highs = []
        self.price_lows = []
        self.rsi_highs = []
        self.rsi_lows = []
        
    def generate_trading_signal(self, current_price, bb_upper, bb_middle, bb_lower, 
                               bb_width, rsi, macd_line, macd_signal, macd_histogram,
                               atr, volume_signal, market_trend, divergence, 
                               black_swan_detected, strategy_mode):
        """ç”Ÿæˆæ™ºèƒ½äº¤æ˜“ä¿¡å·"""
        
        if black_swan_detected:
            return "wait"  # é»‘å¤©é¹…æœŸé—´ç­‰å¾…
        
        # å¸ƒæ—å¸¦å®½åº¦è¿‡æ»¤
        if bb_width < 0.003:  # å¸¦å®½è¿‡çª„ï¼Œå¸‚åœºæ³¢åŠ¨å¤ªå°
            return "wait"
        
        # å¤šé‡ç¡®è®¤ä¿¡å·
        bullish_signals = 0
        bearish_signals = 0
        
        # å¤šå¤´ä¿¡å·ç¡®è®¤
        if current_price <= bb_lower:
            bullish_signals += 1  # å¸ƒæ—å¸¦ä¸‹è½¨
            
        if rsi < 35:
            bullish_signals += 1  # RSIè¶…å–
            
        if macd_histogram > 0 or (macd_line > macd_signal and macd_histogram > -0.001):
            bullish_signals += 1  # MACDè½¬å¼º
            
        if volume_signal:
            bullish_signals += 1  # æˆäº¤é‡ç¡®è®¤
            
        if divergence.get("bullish", False):
            bullish_signals += 2  # çœ‹æ¶¨èƒŒç¦»ï¼ˆæƒé‡æ›´é«˜ï¼‰
            
        if market_trend == "uptrend" and strategy_mode >= 1:
            bullish_signals += 1  # é¡ºåŠ¿äº¤æ˜“åŠ æˆ
            
        # ç©ºå¤´ä¿¡å·ç¡®è®¤
        if current_price >= bb_upper:
            bearish_signals += 1
            
        if rsi > 65:
            bearish_signals += 1
            
        if macd_histogram < 0 or (macd_line < macd_signal and macd_histogram < 0.001):
            bearish_signals += 1
            
        if volume_signal:
            bearish_signals += 1
            
        if divergence.get("bearish", False):
            bearish_signals += 2
            
        if market_trend == "downtrend" and strategy_mode >= 1:
            bearish_signals += 1
        
        # è¶‹åŠ¿è·Ÿéšæ¨¡å¼è¿‡æ»¤
        if strategy_mode >= 1:
            if market_trend == "uptrend" and bearish_signals > 0:
                bearish_signals = 0  # ä¸Šæ¶¨è¶‹åŠ¿ä¸­å¿½ç•¥åšç©ºä¿¡å·
            elif market_trend == "downtrend" and bullish_signals > 0:
                bullish_signals = 0  # ä¸‹è·Œè¶‹åŠ¿ä¸­å¿½ç•¥åšå¤šä¿¡å·
        
        # ä¿¡å·å¼ºåº¦é˜ˆå€¼ï¼ˆæ ¹æ®ç­–ç•¥æ¨¡å¼è°ƒæ•´ï¼‰
        if strategy_mode == 0:  # ä¿å®ˆæ¨¡å¼
            threshold = 4
        elif strategy_mode == 1:  # å¹³è¡¡æ¨¡å¼
            threshold = 3
        else:  # æ¿€è¿›æ¨¡å¼
            threshold = 2
        
        if bullish_signals >= threshold:
            return "buy"
        elif bearish_signals >= threshold:
            return "sell"
        else:
            return "wait"

class ATRStopManager:
    def __init__(self):
        self.initial_stop = 0
        self.trailing_stop = 0
        self.peak_price = 0
        self.valley_price = 0
        
    def calculate_stop_levels(self, position, entry_price, current_price, atr, atr_multiplier):
        """åŸºäºATRè®¡ç®—æ­¢æŸæ°´å¹³"""
        atr_stop_distance = atr * atr_multiplier
        
        if position == 1:  # å¤šå¤´
            # åˆå§‹æ­¢æŸ
            if self.initial_stop == 0:
                self.initial_stop = entry_price - atr_stop_distance
            
            # æ›´æ–°å³°å€¼å’Œç§»åŠ¨æ­¢æŸ
            if current_price > self.peak_price:
                self.peak_price = current_price
                self.trailing_stop = max(self.initial_stop, self.peak_price - atr_stop_distance)
                
            return self.trailing_stop
            
        elif position == -1:  # ç©ºå¤´
            # åˆå§‹æ­¢æŸ
            if self.initial_stop == 0:
                self.initial_stop = entry_price + atr_stop_distance
            
            # æ›´æ–°è°·å€¼å’Œç§»åŠ¨æ­¢æŸ
            if current_price < self.valley_price or self.valley_price == 0:
                self.valley_price = current_price
                self.trailing_stop = min(self.initial_stop, self.valley_price + atr_stop_distance)
                
            return self.trailing_stop
        
        return 0
    
    def reset(self):
        """é‡ç½®æ­¢æŸæ°´å¹³"""
        self.initial_stop = 0
        self.trailing_stop = 0
        self.peak_price = 0
        self.valley_price = 0

def main():
    # å‚æ•°å£°æ˜
    global StrategyMode, BBPeriod, BBStd, BBWidthFilter, TradeAmount, RSIPeriod
    global MACDFast, MACDSlow, MACDSignal, ATRPeriod, ATRMultiplier, VolumeFilter
    global BlackSwanThreshold, BlackSwanCooling, TrendFollowMode, DivergenceDetection, LoopInterval
    
    SetErrorFilter("canceled|ready|timeout|æµæ§")
    
    if len(exchanges) < 1:
        raise Exception("éœ€è¦è‡³å°‘é…ç½®ä¸€ä¸ªäº¤æ˜“æ‰€")
    
    LogReset()
    LogProfitReset()
    cancelAll()
    
    exchange = exchanges[0]
    risk_manager = AdvancedRiskManager()
    signal_generator = SmartSignalGenerator()
    atr_stop_manager = ATRStopManager()
    
    account = _C(exchange.GetAccount)
    initBalance = account.Balance
    initStocks = account.Stocks
    exchangeName = exchange.GetName()
    
    # ç­–ç•¥çŠ¶æ€å˜é‡
    position = 0
    entry_price = 0
    entry_time = 0
    trade_count = 0
    winning_trades = 0
    price_history = []
    high_history = []
    low_history = []
    close_history = []
    volume_history = []
    rsi_history = []
    last_trade_time = 0
    min_amount = 0.001
    
    strategy_modes = {0: "ä¿å®ˆ", 1: "å¹³è¡¡", 2: "æ¿€è¿›"}
    Log(f"ğŸ¯ æ™ºèƒ½é«˜èƒœç‡ç­–ç•¥å¯åŠ¨ - æ¨¡å¼:{strategy_modes[StrategyMode]}, äº¤æ˜“æ‰€:{exchangeName}")

    while True:
        Sleep(LoopInterval)
        
        cmd = GetCommand()
        if cmd:
            Log("CMD", cmd)
            arr = cmd.split(':')
            if arr[0] == 'StrategyMode':
                new_mode = int(arr[1])
                if new_mode in strategy_modes:
                    StrategyMode = new_mode
                    Log(f"åˆ‡æ¢ç­–ç•¥æ¨¡å¼: {strategy_modes[StrategyMode]}")
            elif arr[0] == 'BlackSwan':
                BlackSwanThreshold = float(arr[1])
                Log(f"è°ƒæ•´é»‘å¤©é¹…é˜ˆå€¼: {BlackSwanThreshold}")
        
        # è·å–å¸‚åœºæ•°æ®
        ticker = exchange.GetTicker()
        if not ticker:
            continue
            
        current_price = ticker.Last
        depth = exchange.GetDepth()
        if not depth:
            continue
        
        records = _C(exchange.GetRecords)
        if not records or len(records) < 50:
            continue
        
        # è·å–æœ€æ–°Kçº¿æ•°æ®
        current_high = records[-1].High
        current_low = records[-1].Low
        current_close = records[-1].Close
        current_volume = records[-1].Volume
        
        # æ›´æ–°ä»·æ ¼å†å²
        if len(price_history) >= max(BBPeriod, 50) * 3:
            price_history.pop(0)
            high_history.pop(0)
            low_history.pop(0)
            close_history.pop(0)
            volume_history.pop(0)
            rsi_history.pop(0)
            
        price_history.append(current_price)
        high_history.append(current_high)
        low_history.append(current_low)
        close_history.append(current_close)
        volume_history.append(current_volume)
        
        if len(price_history) < max(BBPeriod, ATRPeriod, RSIPeriod):
            continue
            
        # è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
        bb_upper, bb_middle, bb_lower, bb_width = calculate_bollinger_bands(price_history, BBPeriod, BBStd)
        rsi = calculate_rsi(price_history, RSIPeriod)
        rsi_history.append(rsi)
        macd_line, macd_signal, macd_histogram = calculate_macd(price_history, MACDFast, MACDSlow, MACDSignal)
        atr = calculate_atr(high_history, low_history, close_history, ATRPeriod)
        volume_signal = calculate_volume_signal(current_volume, volume_history, VolumeFilter)
        market_trend = detect_market_trend(price_history)
        
        # æ£€æµ‹èƒŒç¦»
        divergence = {"bullish": False, "bearish": False}
        if DivergenceDetection:
            divergence = detect_rsi_divergence(price_history, rsi_history)
        
        # è·å–è´¦æˆ·ä¿¡æ¯
        account = _C(exchange.GetAccount)
        current_equity = account.Balance + account.Stocks * current_price
        
        # é£é™©ç›‘æ§
        drawdown = risk_manager.calculate_drawdown(current_equity)
        black_swan_detected = risk_manager.check_black_swan(current_price, price_history, BlackSwanThreshold)
        
        # ç”Ÿæˆäº¤æ˜“ä¿¡å·
        signal = signal_generator.generate_trading_signal(
            current_price, bb_upper, bb_middle, bb_lower, bb_width,
            rsi, macd_line, macd_signal, macd_histogram, atr,
            volume_signal, market_trend, divergence, black_swan_detected,
            StrategyMode
        )
        
        # æ›´æ–°ATRæ­¢æŸæ°´å¹³
        if position != 0:
            stop_price = atr_stop_manager.calculate_stop_levels(
                position, entry_price, current_price, atr, ATRMultiplier
            )
        else:
            stop_price = 0
        
        # æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        position_status = "æ— ä»“ä½"
        profit_loss = 0
        signal_strength = "ç­‰å¾…ä¿¡å·"
        
        if position != 0:
            profit_loss = (current_price - entry_price) / entry_price * (1 if position == 1 else -1)
            position_status = f"{'å¤š' if position == 1 else 'ç©º'}å•({_N(profit_loss*100,2)}%)"
            signal_strength = f"æ­¢æŸ:{_N(stop_price,1)}"
        else:
            if signal == "buy":
                signal_strength = "ğŸ“ˆ å¼ºçƒˆåšå¤šä¿¡å·"
            elif signal == "sell":
                signal_strength = "ğŸ“‰ å¼ºçƒˆåšç©ºä¿¡å·"
            else:
                signal_strength = "â³ ç­‰å¾…ç¡®è®¤"
        
        win_rate = _N(winning_trades / trade_count * 100, 1) if trade_count > 0 else 0
        
        status_info = {
            'type': 'table',
            'title': f'ğŸ¯ æ™ºèƒ½é«˜èƒœç‡ç­–ç•¥ - {strategy_modes[StrategyMode]}æ¨¡å¼ - èƒœç‡:{win_rate}%',
            'cols': ['æŒ‡æ ‡', 'æ•°å€¼', 'çŠ¶æ€', 'ä¿¡å·ç¡®è®¤', 'é£é™©ç›‘æ§'],
            'rows': [
                ['ä»·æ ¼', _N(current_price), position_status, 
                 signal_strength, f'äº¤æ˜“:{trade_count}'],
                ['æŠ€æœ¯æŒ‡æ ‡', f'RSI:{_N(rsi,1)} MACD:{_N(macd_histogram,4)}', 
                 f'ATRæ­¢æŸ:{_N(stop_price,1)}' if position !=0 else f'å¸¦å®½:{_N(bb_width*100,3)}%',
                 f'æˆäº¤é‡:{"âœ…" if volume_signal else "âŒ"}', f'èƒœç‡:{win_rate}%'],
                ['å¸‚åœºçŠ¶æ€', market_trend, 
                 f'èƒŒç¦»:{"çœ‹æ¶¨" if divergence["bullish"] else "çœ‹è·Œ" if divergence["bearish"] else "æ— "}',
                 f'é»‘å¤©é¹…:{"ğŸš¨" if black_swan_detected else "âœ…"}', 
                 f'å›æ’¤:{_N(drawdown*100,2)}%']
            ]
        }
        LogStatus('`' + json.dumps(status_info) + '`')
        
        # äº¤æ˜“é€»è¾‘
        trade_executed = False
        
        # ATRæ­¢æŸå¹³ä»“æ¡ä»¶
        if position != 0 and stop_price != 0:
            should_close = False
            close_reason = ""
            
            if position == 1 and current_price <= stop_price:
                should_close = True
                close_reason = f"ATRæ­¢æŸ @{_N(stop_price,1)}"
            elif position == -1 and current_price >= stop_price:
                should_close = True
                close_reason = f"ATRæ­¢æŸ @{_N(stop_price,1)}"
            
            # é»‘å¤©é¹…å¼ºåˆ¶å¹³ä»“
            if black_swan_detected and position != 0:
                should_close = True
                close_reason = "é»‘å¤©é¹…äº‹ä»¶å¼ºåˆ¶å¹³ä»“"
            
            # æ‰§è¡Œå¹³ä»“
            if should_close:
                if position == 1:
                    exchange.Sell(current_price - 1, TradeAmount)
                else:
                    exchange.Buy(current_price + 1, TradeAmount)
                
                # ç»Ÿè®¡èƒœç‡
                if profit_loss > 0:
                    winning_trades += 1
                
                Log(f"å¹³ä»“ - {close_reason}, ç›ˆäº:{_N(profit_loss*100,2)}%")
                position = 0
                atr_stop_manager.reset()
                trade_count += 1
                trade_executed = True
        
        # å¼€ä»“æ¡ä»¶ï¼ˆæ— ä»“ä½ä¸”ä¸åœ¨é»‘å¤©é¹…çŠ¶æ€ï¼‰
        if position == 0 and not trade_executed and not black_swan_detected:
            # æ£€æŸ¥èµ„é‡‘æ˜¯å¦è¶³å¤Ÿ
            can_buy = account.Balance >= current_price * TradeAmount
            can_sell = account.Stocks >= TradeAmount
            
            # æ‰§è¡Œä¿¡å·
            if signal == "buy" and can_buy:
                if exchange.Buy(current_price + 1, TradeAmount):
                    position = 1
                    entry_price = current_price
                    entry_time = time.time()
                    last_trade_time = time.time()
                    Log(f"âš¡æ™ºèƒ½å¼€å¤šä»“ - ä»·æ ¼:{_N(current_price)}, æ¨¡å¼:{strategy_modes[StrategyMode]}")
                    
            elif signal == "sell" and can_sell:
                if exchange.Sell(current_price - 1, TradeAmount):
                    position = -1
                    entry_price = current_price
                    entry_time = time.time()
                    last_trade_time = time.time()
                    Log(f"âš¡æ™ºèƒ½å¼€ç©ºä»“ - ä»·æ ¼:{_N(current_price)}, æ¨¡å¼:{strategy_modes[StrategyMode]}")
        
        # æ›´æ–°åˆ©æ¶¦ç»Ÿè®¡
        current_profit = current_equity - initBalance
        LogProfit(_N(current_profit, 3), 
                 f"èƒœç‡:{win_rate}% äº¤æ˜“:{trade_count} æ¨¡å¼:{strategy_modes[StrategyMode]}")

</CODE>
<LANG>
1
</LANG>
<TYPE>
9</TYPE>
<TIME>
2025-10-19 04:04:50
</TIME>